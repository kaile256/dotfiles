global !p
class Plugin:
  def _raw():
    pat_repo = '^repo = '
    line_repo = vim.eval(f"getline(search('{pat_repo}', 'bnW'))")
    plugin_name_raw = re.sub(r'^.*/(.*)[\'"]', r'\1', line_repo)

    return plugin_name_raw


  def _trimmed():
    prefix = r'^n?vim[-_.]'
    suffix = r'[-_.]n?vim$'

    plugin = Plugin._raw()
    plugin = re.sub(prefix, '', plugin)
    plugin = re.sub(suffix, '', plugin)

    return plugin


  def underscored():
    plugin = Plugin._trimmed()
    underscored = plugin.replace('-', '_')

    return underscored


  def PascalCased():
    plugin = Plugin._trimmed()
    separator = r'[-_.]'
    words = re.split(separator, plugin)

    WordsCapitalized = map(lambda w: w[0].capitalize() + w[1:], words)
    PascalCased = ''.join(WordsCapitalized)

    return PascalCased


class Dein(Plugin):
  def _get_repos():
    """Return a List of repositories gotten from clipboard"""

    clipboard = vim.eval('@+')

    url_github = 'https://github.com'
    pkgm_Plug = "Plug "

    if re.search(url_github, clipboard):
      m = re.search(r'^{url_github}/([^/]*?/[^/]*?)/?$' \
                    .format(url_github = url_github), clipboard)
      repos = [ m.group(1) ]
      repos = map(lambda repo: f"'{repo}'", repos)

    elif re.search(pkgm_Plug, clipboard):
      # Plug 'foo/bar'
      # Plug 'baz/qux'
      #     will be converted to
      # [[plugins]]
      # repo = 'foo/bar'
      # [[plugins]]
      # repo = 'baz/qux'
      repos = []
      stmts = clipboard.split("\n")
      for s in stmts:
        m = re.search(r"'(.*)", f'{s}')
        repos.append(m.group(0))

    elif re.match(r'^[^/]*/[^/]*$', clipboard):
      # foo/bar
      #     to
      # [[plugins]]
      # repo = 'foo/bar'
      repos = [ clipboard ]

    else :
      vim.command('echohl ErrorMsg')
      vim.command(f'echo "[Invalid Format]: @+ is {clipboard}"')
      vim.command('echohl None')
      return ''

    return repos


  def expand_table():
    format_dein = "[[plugins]]\nrepo"

    repos = Dein._get_repos()

    repos = map(lambda r: r if re.match("'", r) else "'" + r + "'", repos)
    tables_dein = map(lambda repo: f'{format_dein} = {repo}', repos)

    return "\n".join(tables_dein)


  def expand_hook(index):
    plugin = Dein._trimmed()

    hook = 'hook_' + index
    source = 'runtime '

    directory = re.sub(r'_.*', '', index)
    path = directory + '/' + plugin + '.vim'

    return hook + " = '" + source + path + "'"


endglobal

snippet dein "[dein] init a table of repo" bA
`!p snip.rv = Dein.expand_table()`
endsnippet

snippet if "if = '$1'" b
if = '${1:has("nvim")}'
endsnippet

snippet 'h(ook_)?a(dd)?' "hook_add = 'runtime add/foo.vim'" br
`!p snip.rv = Dein.expand_hook('add')`
endsnippet

snippet 'h(ook_)?s(ource)?' "hook_source = 'runtime source/foo.vim" br
`!p snip.rv = Dein.expand_hook('source')`
endsnippet

snippet 'h(ook_)?p(ost_)?(s(ource)?)?' "hook_post_source = 'runtime post/foo.vim'" br
`!p snip.rv = Dein.expand_hook('post_souce')`
endsnippet

snippet '(h(ook_)?)?d(one_)?u(pdate)?' "hook_done_update = 'UpdateRemotePlugins'" br
hook_done_update = '${1:call remote#host#UpdateRemotePlugins()}'
endsnippet

snippet 'o(n_)?ft' "on_ft" br
on_ft = '${1:vim}'
endsnippet

snippet 'o(n_)?fu?n?c?' "on_func" br
on_func = '${1:`!p snip.rv = Plugin.underscored()`}#$2'
endsnippet

snippet 'o(n_)?ev?(ent)?' "on_event" br
on_event = '${1:BufRead}'
endsnippet

snippet 'o(n_)?m(ap)?' "on_map" br
on_map = {${1:nox} = '<Plug>(${2:`!p snip.rv = Plugin._trimmed()`}-${3:foo}'}
endsnippet

snippet 'o(n_)?c(md)?' "on_cmd" br
on_cmd = '${1:`!p snip.rv = Plugin.PascalCased()`}'
endsnippet

snippet 'o(n_)?p(ath)?' "on_path" br
on_path = [${1:'\.js$', '\.jsx$', '\.ts$', '\.tsx$'}]
endsnippet

snippet 'o(n_)?s(ource)?' "[dein] load the plugin before the listed plugins're loaded" br
on_source = '${1:vim-fugitive}'
endsnippet

snippet build "[dein] shellcmd after update of repo" b
build = '${1:bash install.sh}'
endsnippet

snippet type "[dein] 'git', 'none', or 'raw (with 'script_type')'" b
type = '${1:git}'
endsnippet

snippet depends "[dein] add dependence upon other plugins" b
depends = '${1:vim-fugitive}'
endsnippet

snippet 'sudo|trusted' "trusted = 1 (load plugin as in 'sudo'" rb
trusted = 1
endsnippet

snippet timeout "[dein] timeout sec for updating/installing plugin" b
timeout = ${1:200 # 1(sec)}
endsnippet

snippet script_type "[dein] copy the repo under $1/ and add &rtp there" b
script_type = '${1:colors}'
endsnippet

snippet merged "[dein] if 0, merge conflicts with other plugins"
merged = 0
endsnippet

snippet lazy "[dein] `lazy = 0` to stop lazy-load" b
lazy = 0
endsnippet
